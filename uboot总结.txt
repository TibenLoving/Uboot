/*********************************************/

//如果使用远程编译
obj = $(OBJTREE)/	//远程编译的路径
src = $(SRCTREE)/ 	//源文件的路径
//本地编译
obj = 
src =


VERSION = 1             //主版本号
PATCHLEVEL = 3		//次版本号
SUBLEVEL = 4 		//次次版本号
EXTRAVERSION =
U_BOOT_VERSION = 1.3.4  //uboot版本号
VERSION_FILE = $(obj)include/version_autogenerated.h  // 内容为：#define U_BOOT_VERSION "U-Boot 1.3.4"  version_autogenerated.h 编译后自动生成的文件
HOSTARCH = i386		//主机版本号
HOSTOS = linux		//主机内核
VENDOR=
XECHO  //是否静默编译

BUILD_DIR =      	//编译路径 编译后生成的文件存放路径  （默认为本地编译，即等于本源文件的路径）

OBJTREE	= $(CURDIR)	//生成的OBJ存放路径     此处为本源文件的路径
SRCTREE	= $(CURDIR)	//源文件的路径
TOPDIR	= $(SRCTREE)	//最开始的目录路径  	等于本源文件的路径
LNDIR	= $(OBJTREE) 	//链接的路径    	等于本源文件的路径


MKCONFIG  = /uboot/mkconfig


REMOTE_BUILD  =   //远程编译的标志，如果使用远程编译则为1 ，此处不为一


// 133行导入了$(obj)include/config.mk    在每次配置时 make x210_sd_config  ，
/* 把 	ARCH   = arm
	CPU    = s5pc11x
	BOARD  = x210
	VENDOR = samsung
	SOC    = s5pc110  写入$(obj)include/config.mk  	
*/

CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-   //交叉编译工具链的前面一段字符

//185 行导入  include $(TOPDIR)/config.mk  本源文件的config.mk

PLATFORM_RELFLAGS =$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
PLATFORM_CPPFLAGS = -DCONFIG_ARM -D__ARM__ $(call cc-option,-mapcs-32,-mabi=apcs-gnu) $(call cc-option,-mno-thumb-interwork,)
PLATFORM_LDFLAGS =

HOSTCC		= gcc

//$(TOPDIR)/config.mk中112行包含了 $(OBJTREE)/include/autoconf.mk ， 此文件编译后自动生成   ，关于一些配置条件编译
//$(TOPDIR)/config.mk中115行包含了 $(TOPDIR)/$(ARCH)_config.mk              arm架构
//$(TOPDIR)/config.mk中121行包含了 $(TOPDIR)/cpu/$(CPU)/config.mk	    S5PC11X
//$(TOPDIR)/config.mk中121行包含了 $(TOPDIR)/cpu/$(CPU)/$(SOC)/config.mk    SPPC110
//$(TOPDIR)/config.mk中129行包含了 $(TOPDIR)/board/$(BOARDDIR)/config.mk    X210     TEXT_BASE = 0xc3e00000   在每次配置时 make x210_sd_config 写入

BOARDDIR = $(VENDOR)/$(BOARD)   //samsung/x210

HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer

AFLAGS = -g  -Os  $(PLATFORM_RELFLAGS) -DTEXT_BASE=0xc3e00000  -I$(TOPDIR)/include -fno-builtin -ffreestanding -nostdinc -isystem $(shell $(CC) -print-file-name=include) -pipe $(PLATFORM_CPPFLAGS)
CFLAGS =
CPPFLAGS =
LDFLAGS  =  -Bstatic -T  $(TOPDIR)/board/$(VENDOR)/$(BOARD)/u-boot.lds   //-Bstatic -T  /uboot/board/samsung/x210/u-boot.lds -Ttext 0xc3e00000

OBJS = $(obj)/$(OBJS) ....  //$(obj)start.o $(obj)cpu/$(CPU)/start.o  ....

第一个：在include目录下创建asm文件，指向asm-arm。（46-48行）
第二个：在inlcude/asm-arm下创建一个arch文件，指向include/asm-arm/arch-s5pc110
第三个：在include目录下创建regs.h文件，指向include/s5pc110.h
删除第二个。
第四个：在inlcude/asm-arm下创建一个arch文件，指向include/asm-arm/arch-s5pc11x
第五个：在include/asm-arm下创建一个proc文件，指向include/asm-arm/proc-armv



start.S :

CFG_PHY_UBOOT_BASE ： 0x33e00000   uboot在DDR中的物理地址

PRO_ID_BASE + OMR_OFFSET  =0xe0000004    反应OM Pin脚状态的寄存器

ldr	r0, =INF_REG_BASE
str	r3, [r0, #INF_REG3_OFFSET]      //把当前的OM Pin脚的状态也存放在INFORM3，这个寄存器是使用者自己定义信息的寄存器

push {lr}  //压栈，保存返回地址


/* check reset status  检查设备以哪种方式唤醒  P456页*/

ldr	r0, =(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET) //0xE0100000 +0xa000
ldr	r1, [r0]
bic	r1, r1, #0xfff6ffff      
cmp	r1, #0x10000                    
beq	wakeup_reset_pre            //属于睡眠状态唤醒复位
cmp	r1, #0x80000
beq	wakeup_reset_from_didle     //属于待机状态唤醒复位

/* IO Retention release */
ldr	r0, =(ELFIN_CLOCK_POWER_BASE + OTHERS_OFFSET)//0xE0100000 +0xe000
ldr	r1, [r0]
ldr	r2, =IO_RET_REL           31bit、29bit、28bit
orr	r1, r1, r2
str	r1, [r0]



虚拟地址映射：使用的是段映射方式（1MB）【细表1KB，粗表4KB，段1MB】



虚拟地址           	物理地址    	 	长度             权限

0-0x100M           	0-100M         		256M            不进行权限检查,管理员模式和普通用户都可以读写访问这段内存,
0x100M-0x200M   	0					256M 		
0x200M-0x600M		0x200M-0x600M 		1G				不进行权限检查,管理员模式和普通用户都可以读写访问这段内存		DRAM - DMC0、1 area  512M
0x600M-0x800M   	0 					512M 
0x800M-0xB00M		0x800M-0xB00M 		768M			不进行权限检查,管理员模式和普通用户都可以读写访问这段内存
0xB00M-0xC00M		0xB00M-0xC00M 		256M			不进行权限检查,管理员模式和普通用户都可以读写访问这段内存
0xC00M-0xD00M		0x300M-0x400M 		256M			不进行权限检查,管理员模式和普通用户都可以读写访问这段内存		DRAM - DMC0 area
0xD00M-0x1000M		0xD00M-0x1000M 		768M			不进行权限检查,管理员模式和普通用户都可以读写访问这段内存



uBOOT过程：
//第一阶段
start.s：
16字节校验头填充
reset:  设置为SVC模式、IRQ和FIQ禁止
禁止L2 cache 、初始化L2 cache 、再使能L2 cache 
使无效TLB和icache
禁止MMU（选择低端异常中断向量 0x0~0x1c 、禁止数据 / 整个 cache 、禁止 MMU 或者 PU、禁止 MMU 或者 PU  ）
读取OM PIN 状态，并保存在INF_REG3_OFFSET寄存器中
设置SRAM里的栈，地址为0xd0036000-12
lowlevel_init:
压栈
检查复位状态、判断冷、热启动
IO口之前电平状态释放
禁止看门狗
PS_HOLD设置
检测是否需要重定位，需要则跳过时钟初始化、内存初始化
时钟初始化
内存初始化
串口2初始化，打印‘O’字
tzpc初始化
ABB禁止
打印‘K’字
出栈	去 
start.s：
PS_HOLD设置
设置DDR里的栈，栈地址为0x33e00000 - 12,为满减栈
查看当前程序运行的地址，看是否需要复制BL的第二部分 到 DDR中去
从SD 卡中的第49个块 复制BL的第二部分 （512 K ） 到 DDR中去，地址为0x33e00000

MMU:设置域的权限、设置 一级映射描述符表的基地址（物理地址）（0x33e00000 + _mmu_table_base所在内存地址的偏移）、打开MMU

再次设置栈 地址为0x33e00000 + 2M -4K （2044K可用）

清除BSS段

使用远跳转，跳到DDR中的start_armboot去
//第二阶段
初始化init_sequence:
cpu_init		        //什么也没干
board_init			//网卡DM9000初始化、机器码配置（2456）和uboot的参数配置（0x30000000+0x100），里面存放了将来要传给内核的参数的地址，0x30000000+0x100	
interrupt_init			//初始化定时器4、使用MPCLK作为时钟源（不清楚为什么要用MPCLK），定时10ms
env_init			//环境变量初始化，gd->env_valid = 1;
init_baudrate			//波特率初始化，默认115200
console_init_f			//gd->have_console = 1;
display_banner			//显示启动信息    	U-Boot 1.3.4-Tiben (Feb 21 2018 - 05:44:49) for x210
print_cpuinfo			//打印cpu信息		CPU:  S5PV210@1000MHz(OK)
        						        APLL = 1000MHz, HclkMsys = 200MHz, PclkMsys = 100MHz
        						        MPLL = 667MHz, EPLL = 96MHz
							        HclkDsys = 166MHz, PclkDsys = 83MHz
							        HclkPsys = 133MHz, PclkPsys = 66MHz
							        SCLKA2M  = 200MHz
							        Serial = CLKUART
checkboard			//打印开发板信息		Board:   X210
dram_init			//DDR软件信息初始化
display_dram_config		//打印DDR总容量			DRAM:    512 MB

初始化Nor flash，不要删掉，删掉的话其他地方会报错		Flash:   8 MB
malloc的初始化，配置malloc时所需的堆内存地址

/**下面关于x210板的初始化**/
mmc设备的SOC控制器初始化和卡的初始化				SD/MMC:  3776MB
nand的初始化
/*************************/

env_relocate ();环境变量的重定位，（
如果gd->env_valid == 0，则从代码段的环境变量写到DDR里的堆里面去大小为16K，有4个字节的CRC和1字节的flag（flag==0xff），其他的为环境变量。（但不知道怎么存储到SD卡去）
否则，则从SD卡里的环境变量分区写到DDR里的堆里面去，分区里用了多少个块存储了环境变量就写多少个块进去。

gd->bd->bi_ip_addr 初始化(赋值)
gd->bd->bi_enetaddr初始化(赋值)

devices_init ();设备初始化，这里没怎么初始化
jumptable_init ();跳转表初始化
console_init_r ();控制台第二部分初始化				In:      serial
								Out:     serial
								Err:     serial
enable_interrupts ();由于没有使能中断，所以这里空执行
loadaddr、bootfile从环境变量赋值全局变量，与内核启动有关
board_late_init ();开发板最后的初始化，这里执行空
eth_initialize(gd->bd);有关网卡初始化，这里也没干什么
x210_preboot_init();开发板开机引导的LCD图标初始化
检查是否需要SD卡更新，如果按下了LEFT按键			[LEFT UP] boot mode
进入main_loop ();{
  判断这里是否为真  if (bootdelay >= 0 && s && !abortboot (bootdelay)) {}  //如果在bootdelay时间内按下了任何键，则abortboot (bootdelay) = 1 .否则为0
  真：
执行				parse_string_outer(s, FLAG_PARSE_SEMICOLON |FLAG_EXIT_FROM_LOOP);分号解析，退出循环 
//使用分号解析将movi read kernel 30008000; movi read rootfs 30B00000 300000; bootm 30008000 30B00000  分成3部分，然后使用下面的顺序执行3次，最后一次直接跳出循环到30008000 30B00000  内核中去
  
				parse_stream_outer(&input, FLAG_PARSE_SEMICOLON)
				run_list(ctx.list_head);
				run_list_real(pi);  
				run_pipe_real(pi);
				find_cmd (const char *cmd)
				code = (cmdtp->cmd)(cmdtp, flag,child->argc-i,&child->argv[i]);
				do_movi();/do_bootm();
			        run_command(XX,XX);
  s = getenv ("bootcmd");最后应该执行 movi read kernel 30008000; movi read rootfs 30B00000 300000; bootm 30008000 30B00000
  调到内核去
  假：使用HUSH 解析       执行一行命令的顺序 ：
				parse_file_outer() 
				parse_stream_outer(&input, FLAG_PARSE_SEMICOLON)
				run_list(ctx.list_head);
				run_list_real(pi);  
				run_pipe_real(pi);
				code = (cmdtp->cmd)(cmdtp, flag,child->argc-i,&child->argv[i]); 
				do_XXX();
				/run_command(XX,XX);

#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r8")
//定义了一个存放在寄存器r8中的寄存器类型、易变的、指向gd_t结构体的指针gd 。

//include/asm/-arm/Global_data  --- 存放全局变量 ---
typedef	struct	global_data {
	bd_t		*bd;                            			//开发板的硬件信息
	unsigned long	flags;							//
	unsigned long	baudrate;						//波特率
	unsigned long	have_console;	/* serial_init() was called */		//是否有控制台
	unsigned long	reloc_off;	/* Relocation Offset */			//重定位偏移量
	unsigned long	env_addr;	/* Address  of Environment struct */	//环境变量的地址（在代码段）
	unsigned long	env_valid;	/* Checksum of Environment valid? */	//内存的环境变量是否有效
	unsigned long	fb_base;	/* base address of frame buffer */	//LCD缓存的地址
#ifdef CONFIG_VFD
	unsigned char	vfd_type;	/* display type */
#endif
#if 0
	unsigned long	cpu_clk;	/* CPU clock in Hz!		*/
	unsigned long	bus_clk;
	phys_size_t	ram_size;	/* RAM size */
	unsigned long	reset_status;	/* reset status register at boot */
#endif
	void		**jt;		/* jump table */			//转换表
} gd_t;

//include/asm/-arm/U-boot.h  --- 开发板的硬件信息 ---
typedef struct bd_info {
    int			bi_baudrate;	/* serial console baudrate */
    unsigned long	bi_ip_addr;	/* IP Address */
    unsigned char	bi_enetaddr[6]; /* Ethernet adress */			//
    struct environment_s	       *bi_env;
    ulong	        bi_arch_number;	/* unique id for this board */		//机器码
    ulong	        bi_boot_params;	/* where this board expects params */	//启动参数  存放的是将来传给内核的参数的地址0x30000100
    struct				/* RAM configuration */
    {
	ulong start;
	ulong size;
    }			bi_dram[CONFIG_NR_DRAM_BANKS];  			//DRAM的信息
#ifdef CONFIG_HAS_ETH1
    /* second onboard ethernet port */
    unsigned char   bi_enet1addr[6];
#endif
} bd_t;

环境变量的优先级，先使用环境变量，没有的话使用程序的变量。
执行env_relocate时，会判断SD卡中的env分区的crc是否通过。如果crc通过则说明SD卡中有正确的环境变量存储，
则会从SD中读取环境变量来作为当前的环境变量。

typedef	struct environment_s {
	uint32_t	crc;		/* CRC32 over data bytes	*/
#ifdef CFG_REDUNDAND_ENVIRONMENT
	unsigned char	flags;		/* active/obsolete flags	*/
#endif
	unsigned char	data[ENV_SIZE]; /* Environment data		*/  16k - 4Byte
} env_t;



CPU:  S5PV210@1000MHz(OK)
        APLL = 1000MHz, HclkMsys = 200MHz, PclkMsys = 100MHz
        MPLL = 667MHz, EPLL = 96MHz
                       HclkDsys = 166MHz, PclkDsys = 83MHz
                       HclkPsys = 133MHz, PclkPsys = 66MHz
                       SCLKA2M  = 200MHz
					   
					   
在命令行输入 bdinfo ：可以显示板子的信息

DDR内存分布：

0x33e00000+2M						

0x33e00000+2M -4K				栈的开始地址

0x33e00000+2M -512K				栈的结束地址 | 堆区的结束地址
                          <  环境变量在这里  16k>
0x33e00000+2M -512K-912K			堆区的开始地址开始

0x33e00000+2M -512K-912K - gd			gd的地址 36个字节

0x33e00000+2M -512K-912K - gd - bd		bd的地址

0x33e00000+512k  				uboot的重定位结束地址

0x33e00000					uboot的重定位开始地址

0x30008000+64字节+代码偏移量			theKernel

0x30008000+64字节				内核头部信息结束

0x30008000					内核地址   头部信息开始

0x30000000+0x148+8				传参的参数结束

0x30000000+0x148				setup_end_tag 

0x30000000+0x134				MTDPARTITION tag 开始   SD卡的分区表

0x30000000+0x124				memory2 tag 开始

0x30000000+0x114				memory1 tag 开始

0x30000000+0x100				存放将来传给内核的参数的地址，setup_start_tag开始，传参开始


/**********************************************************************************************/
bootm_headers_t类型的images全局static变量：指向内核、内存磁盘、文件目录表的镜像
typedef struct bootm_headers {
	/*
	 * Legacy os image header, if it is a multi component image
	 * then boot_get_ramdisk() and get_fdt() will attempt to get
	 * data from second and third component accordingly.
	 */
	image_header_t	*legacy_hdr_os;		/* image header pointer */ // 将image_header_t类型的hdr的地址复制到这里，0x30008000     
	image_header_t	legacy_hdr_os_copy;	/* header copy */	  //将image_header_t类型的hdr复制到这里legacy_hdr_os_copy
	ulong		legacy_hdr_valid;				//复制完成后标志位有效 legacy_hdr_valid = 1;

#if defined(CONFIG_FIT) //设备树
	const char	*fit_uname_cfg;	/* configuration node unit name */

	void		*fit_hdr_os;	/* os FIT image header */
	const char	*fit_uname_os;	/* os subimage node unit name */
	int		fit_noffset_os;	/* os subimage node offset */

	void		*fit_hdr_rd;	/* init ramdisk FIT image header */
	const char	*fit_uname_rd;	/* init ramdisk subimage node unit name */
	int		fit_noffset_rd;	/* init ramdisk subimage node offset */
#endif

	int		verify;		/* getenv("verify")[0] != 'n' */
	struct lmb	*lmb;		/* for memory mgmt */
} bootm_headers_t;
/**********************************************************************************************/

//image_header_t类型的hdr的地址为内核地址0x30008000    4*7+36 = 64字节头部信息
typedef struct image_header {
	uint32_t	ih_magic;	/* Image Header Magic Number	*/		镜像头的魔数
	uint32_t	ih_hcrc;	/* Image Header CRC Checksum	*/		头部CRC校验
	uint32_t	ih_time;	/* Image Creation Timestamp	*/		镜像时间戳
	uint32_t	ih_size;	/* Image Data Size		*/		镜像数据段的大小		
	uint32_t	ih_load;	/* Data	 Load  Address		*/		镜像的数据段的地址
	uint32_t	ih_ep;		/* Entry Point Address		*/		内核入口地址		0x30008000	
	uint32_t	ih_dcrc;	/* Image Data CRC Checksum	*/		数据段CRC校验
	uint8_t		ih_os;		/* Operating System		*/   		操作系统         	IH_OS_LINUX
	uint8_t		ih_arch;	/* CPU architecture		*/		CPU架构
	uint8_t		ih_type;	/* Image Type			*/		镜像类型
	uint8_t		ih_comp;	/* Compression Type		*/		压缩类型
	uint8_t		ih_name[IH_NMLEN];	/* Image Name		*/		//镜像名称 32字节
} image_header_t;
/**********************************************************************************************/
//传参用的数据结构
struct tag_header {
	u32 size;//tag大小
	u32 tag;//tag类型
};
//传参是以一个一个的tag来传参，每个tag都有不同的类型  起始TAG是ATAG_CORE、结束tag是ATAG_NONE
struct tag {
        struct tag_header hdr;
        union { 
                struct tag_core         core;
                struct tag_mem32        mem;
                struct tag_videotext    videotext;
                struct tag_ramdisk      ramdisk;
                struct tag_initrd       initrd;
                struct tag_serialnr     serialnr;
                struct tag_revision     revision;
                struct tag_videolfb     videolfb;
                struct tag_cmdline      cmdline;
                
                /*
                * Acorn specific
                */
                struct tag_acorn        acorn;
                
                /*
                 * DC21285 specific
                 */
                struct tag_memclk       memclk;
                
                struct tag_mtdpart      mtdpart_info;
        } u;
}
/**********************************************************************************************/


theKernel (0, machid, bd->bi_boot_params);  //传参传了3个参数，第一个为0，放在r0，第二个为机器码，放在R1，第三个为一些参数所在的内存首地址，为0x30000100，放在R3，最后以寄存器的方式传参给内核

static struct tag *params;

（1）内存参数传参
（2）命令行的参数
"console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3"

（3）分区表
"80000 400000 3000000"

传参的具体分布：
0x30000000+0x100
	ATAG_CORE
		tag_header{
			u32 size=5 （20byte/4） 
			u32 tag=ATAG_CORE（0x54410001） 
			}
		struct tag_core {
			u32 flags = 0;		/* bit 0 = read-only */
			u32 pagesize = 0;
			u32 rootdev = 0;
			}
			
	ATAG_MEM
		tag_header{
			u32 size=6 （24byte/4） 
			u32 tag=ATAG_MEM（0x54410002） 
			}
		struct tag_mem32 { /*内存块1信息*/
			u32	size = 256M;
			u32	start = 0x30000000;	/* physical start address */
			}
		struct tag_mem32 {/*内存块2信息*/
			u32	size = 256M;
			u32	start = 0x40000000;	/* physical start address */
			}
			
	ATAG_CMDLINE
		tag_header{
			u32 size= 2 + strlen(cmdline)/4 
			u32 tag=ATAG_CMDLINE（0x54410009） 
			}
		struct tag_cmdline {
			char	cmdline[1] = "console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3";	 /* this is the minimum size */
			};
			
	ATAG_INITRD2
		tag_header{
			u32 size=4 （16byte/4） 
			u32 tag=ATAG_INITRD2（0x54420005） 
			}
		struct tag_initrd {
			u32 start;	/* physical start address */
			u32 size;	/* size of compressed ramdisk image in bytes */
			};
			
	ATAG_MTDPART
		tag_header{
			u32 size=5 （20byte/4） 
			u32 tag=ATAG_INITRD2（0x54420005） 
			}
		struct tag_mtdpart {
			u32 mtd_part_size[3] = {0x80000 0x400000 0x3000000};
			};
			
	ATAG_NONE	
		tag_header{
			u32 size=2 （8byte/4） 
			u32 tag=ATAG_NONE（0x00000000） 
			}	
传参结束	
		
/**********************************************************************************************/
//命令行的结构体
struct cmd_tbl_s {
	char		*name;		/* Command Name			*/  	命令名称
	int		maxargs;	/* maximum number of arguments	*/	最大数量的参数
	int		repeatable;	/* autorepeat allowed?		*/	是否可重复执行		
					/* Implementation function	*/
	int		(*cmd)(struct cmd_tbl_s *, int, int, char *[]);		命令执行函数的指针	
	char		*usage;		/* Usage message	(short)	*/	短信息help
#ifdef	CFG_LONGHELP
	char		*help;		/* Help  message	(long)	*/	长信息help
#endif
#ifdef CONFIG_AUTO_COMPLETE							自动补全
	/* do auto completion on the arguments */
	int		(*complete)(int argc, char *argv[], char last_char, int maxv, char *cmdv[]);
#endif
};
/**********************************************************************************************/
命令段属性
#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \
cmd_tbl_t __u_boot_cmd_##name Struct_Section = {#name, maxargs, rep, cmd, usage, help}

#define Struct_Section  __attribute__ ((unused,section (".u_boot_cmd")))
/**********************************************************************************************/

void	(*theKernel)(int zero, int arch, uint params)；//镜像内核的入口函数格式


init_raw_area_table初始化原始分区表（sd卡分区）
BL1  			raw_area_control.image[1].start_blk = 第1个块   raw_area_control.image[1].used_blk = 16个块
environment  	raw_area_control.image[2].start_blk = 第17个块   raw_area_control.image[2].used_blk = 32个块
BL2  			raw_area_control.image[3].start_blk = 第49个块   raw_area_control.image[3].used_blk = 1024个块
kernel  		raw_area_control.image[4].start_blk = 第1073个块   raw_area_control.image[4].used_blk = 4*1024*1024/512 = 8*1024 = 8192个块
RFS  			raw_area_control.image[5].start_blk = 第9265个块   raw_area_control.image[5].used_blk = 26*1024*1024/512个块		



